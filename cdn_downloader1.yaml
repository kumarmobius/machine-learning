name: ML Artifacts Downloader v4.
inputs:
  - {name: preprocessor_metadata_cdn, type: String, description: "CDN URL to download preprocessor metadata artifact", optional: true, default: ""}
  - {name: feature_selector_cdn, type: String, description: "CDN URL to download feature selector artifact", optional: true, default: ""}
  - {name: pca_cdn, type: String, description: "CDN URL to download PCA artifact", optional: true, default: ""}
  - {name: preprocessor_cdn, type: String, description: "CDN URL to download preprocessor artifact", optional: true, default: ""}
  - {name: x_train_cdn, type: String, description: "CDN URL to download training features dataset", optional: true, default: ""}
  - {name: y_train_cdn, type: String, description: "CDN URL to download training labels dataset", optional: true, default: ""}
  - {name: test_data_cdn, type: String, description: "CDN URL to download test dataset", optional: true, default: ""}
  - {name: bearer_token, type: string, description: "Optional path to file containing bearer token for authenticated downloads", optional: true, default: ""}
outputs:
  - {name: preprocessor_metadata_local, type: Data, description: "Local path for downloaded preprocessor metadata"}
  - {name: feature_selector_local, type: Data, description: "Local path for downloaded feature selector"}
  - {name: pca_local, type: Data, description: "Local path for downloaded PCA"}
  - {name: preprocessor_local, type: Data, description: "Local path for downloaded preprocessor"}
  - {name: x_train_local, type: Dataset, description: "Local path for downloaded x_train dataset"}
  - {name: y_train_local, type: Dataset, description: "Local path for downloaded y_train dataset"}
  - {name: test_data_local, type: Dataset, description: "Local path for downloaded test_data dataset"}

implementation:
  container:
    image: kumar2004/ml-base:v1
    command:
      - python3
      - -u
      - -c
      - |
        import argparse, os, sys, tempfile, shutil, zipfile, logging, re
        import requests
        from requests.adapters import HTTPAdapter
        try:
            from urllib3.util import Retry
        except Exception:
            from urllib3 import Retry

        parser = argparse.ArgumentParser()
        parser.add_argument('--preprocessor_metadata_cdn', type=str, default="")
        parser.add_argument('--feature_selector_cdn', type=str, default="")
        parser.add_argument('--pca_cdn', type=str, default="")
        parser.add_argument('--preprocessor_cdn', type=str, default="")
        parser.add_argument('--x_train_cdn', type=str, default="")
        parser.add_argument('--y_train_cdn', type=str, default="")
        parser.add_argument('--test_data_cdn', type=str, default="")
        parser.add_argument('--bearer_token', type=str, default="")
        parser.add_argument('--preprocessor_metadata_local', type=str, required=True)
        parser.add_argument('--feature_selector_local', type=str, required=True)
        parser.add_argument('--pca_local', type=str, required=True)
        parser.add_argument('--preprocessor_local', type=str, required=True)
        parser.add_argument('--x_train_local', type=str, required=True)
        parser.add_argument('--y_train_local', type=str, required=True)
        parser.add_argument('--test_data_local', type=str, required=True)
        args = parser.parse_args()

        logging.basicConfig(stream=sys.stdout, level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")
        logger = logging.getLogger("ml_artifacts_downloader")

        session = requests.Session()
        try:
            retry_strategy = Retry(
                total=3,
                backoff_factor=1,
                status_forcelist=[500, 502, 503, 504],
                allowed_methods=frozenset(["GET", "HEAD"])
            )
        except TypeError:
            retry_strategy = Retry(
                total=3,
                backoff_factor=1,
                status_forcelist=[500, 502, 503, 504],
                method_whitelist=frozenset(["GET", "HEAD"])
            )

        adapter = HTTPAdapter(max_retries=retry_strategy)
        session.mount("http://", adapter)
        session.mount("https://", adapter)

        headers = {}
        if args.bearer_token and os.path.exists(args.bearer_token):
            with open(args.bearer_token, "r", encoding="utf-8") as f:
                token = f.read().strip()
                if token:
                    headers["Authorization"] = f"Bearer {token}"

        def convert_to_three_dollars(url):
            if "$$$" in url:
                return url
            elif "$$" in url:
                return url.replace("$$", "$$$")
            elif "_$_" in url:
                return url.replace("_$_", "_$$$_")
            return url

        def try_download(url):
            logger.info("Attempting download: %s", url)
            r = session.get(url, headers=headers, timeout=120)
            r.raise_for_status()
            fd, tmp = tempfile.mkstemp(suffix=".download")
            os.close(fd)
            with open(tmp, "wb") as fh:
                fh.write(r.content)
            return tmp

        def download_with_fallback(url):
            """Try downloading with $$$ first, then fall back to original URL"""
            original_url = url
            
            # First attempt: Convert to $$$ if not already
            three_dollar_url = convert_to_three_dollars(url)
            
            if three_dollar_url != original_url:
                logger.info("Trying with $$$ URL first: %s", three_dollar_url)
                try:
                    return try_download(three_dollar_url)
                except Exception as e:
                    logger.warning("Download with $$$ failed: %s", e)
                    logger.info("Falling back to original URL: %s", original_url)
                    try:
                        return try_download(original_url)
                    except Exception as e2:
                        logger.error("Both download attempts failed")
                        raise e2
            else:
                # URL already has $$$, just try it
                return try_download(original_url)

        def place_artifact(tmp_file, out_path):
            try:
                with zipfile.ZipFile(tmp_file, "r") as z:
                    os.makedirs(out_path, exist_ok=True)
                    z.extractall(out_path)
                    os.remove(tmp_file)
                    return out_path
            except zipfile.BadZipFile:
                os.makedirs(os.path.dirname(out_path) or ".", exist_ok=True)
                shutil.move(tmp_file, out_path)
                return out_path

        def fetch_artifact(url, out_path):
            if not url or not url.strip():
                os.makedirs(os.path.dirname(out_path) or ".", exist_ok=True)
                with open(out_path, "w") as fh:
                    fh.write("")
                return None
            tmp = download_with_fallback(url)
            return place_artifact(tmp, out_path)

        fetch_artifact(args.preprocessor_metadata_cdn, args.preprocessor_metadata_local)
        fetch_artifact(args.feature_selector_cdn, args.feature_selector_local)
        fetch_artifact(args.pca_cdn, args.pca_local)
        fetch_artifact(args.preprocessor_cdn, args.preprocessor_local)
        fetch_artifact(args.x_train_cdn, args.x_train_local)
        fetch_artifact(args.y_train_cdn, args.y_train_local)
        fetch_artifact(args.test_data_cdn, args.test_data_local)

        logger.info("All artifacts downloaded successfully")

    args:
      - --preprocessor_metadata_cdn
      - {inputValue: preprocessor_metadata_cdn}
      - --feature_selector_cdn
      - {inputValue: feature_selector_cdn}
      - --pca_cdn
      - {inputValue: pca_cdn}
      - --preprocessor_cdn
      - {inputValue: preprocessor_cdn}
      - --x_train_cdn
      - {inputValue: x_train_cdn}
      - --y_train_cdn
      - {inputValue: y_train_cdn}
      - --test_data_cdn
      - {inputValue: test_data_cdn}
      - --bearer_token
      - {inputPath: bearer_token}
      - --preprocessor_metadata_local
      - {outputPath: preprocessor_metadata_local}
      - --feature_selector_local
      - {outputPath: feature_selector_local}
      - --pca_local
      - {outputPath: pca_local}
      - --preprocessor_local
      - {outputPath: preprocessor_local}
      - --x_train_local
      - {outputPath: x_train_local}
      - --y_train_local
      - {outputPath: y_train_local}
      - --test_data_local
      - {outputPath: test_data_local}
