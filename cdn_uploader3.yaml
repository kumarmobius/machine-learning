name: Model CDN uploader v4
inputs:
  - {name: model_pickle, type: Model, description: "Saved model pickle/joblib file to upload"}
  - {name: model_metadata_cdn, type: Data, description: "Model metadata file to upload"}
  - {name: bearer_token, type: string, description: "Path to a file containing bearer token (will be read)"}
  - {name: domain, type: String, description: "Domain root for upload endpoint, e.g. https://api.example.com"}
  - {name: get_cdn, type: String, description: "CDN base URL to prefix returned relative cdnUrl"}
  - {name: name, type: String, description: "Friendly name to include in schema CDN JSON"}

outputs:
  - {name: schema_cdn_json, type: String, description: "JSON containing model CDN URLs and name"}

implementation:
  container:
    image: gurpreetgandhi/nesy-factory:vtest4
    command:
      - python3
      - -u
      - -c
      - |
        import argparse
        import subprocess
        import json
        import os
        import uuid
        import tempfile
        import shutil
        import sys
        import traceback

        parser = argparse.ArgumentParser(description="Upload model + metadata to CDN.")
        parser.add_argument('--model_pickle', type=str, required=True)
        parser.add_argument('--model_metadata_cdn', type=str, required=True)
        parser.add_argument('--bearer_token', type=str, required=True)
        parser.add_argument('--domain', type=str, required=True)
        parser.add_argument('--get_cdn', type=str, required=True)
        parser.add_argument('--name', type=str, required=True)
        parser.add_argument('--schema_cdn_json', type=str, required=True)
        args = parser.parse_args()

        def ensure_parent_dir(path):
            parent = os.path.dirname(path)
            if parent:
                os.makedirs(parent, exist_ok=True)

        def atomic_write_json(path, data):
            ensure_parent_dir(path)
            fd, tmp = tempfile.mkstemp(prefix="tmp_json_")
            try:
                with os.fdopen(fd, "w", encoding="utf-8") as f:
                    json.dump(data, f, ensure_ascii=False)
                os.replace(tmp, path)
            except Exception:
                try:
                    os.remove(tmp)
                except Exception:
                    pass
                raise

        def encode_special_chars(text):
            return (
                text.replace("$", "%24")
                    .replace("(", "%28")
                    .replace(")", "%29")
                    .replace("[", "%5B")
                    .replace("]", "%5D")
                    .replace("{", "%7B")
                    .replace("}", "%7D")
            )

        with open(args.bearer_token, "r", encoding="utf-8") as f:
            bearer_token = f.read().strip()

        upload_url = (
            f"{args.domain.rstrip('/')}"
            "/mobius-content-service/v1.0/content/upload"
            "?filePathAccess=private&filePath=%2Fbottle%2Flimka%2Fsoda%2F"
        )

        def run_upload(path):
            cmd = [
                "curl",
                "--location", upload_url,
                "--header", f"Authorization: Bearer {bearer_token}",
                "--form", f"file=@{path}",
                "--fail",
                "--show-error"
            ]
            p = subprocess.run(cmd, capture_output=True)
            if p.returncode != 0:
                raise RuntimeError(p.stderr.decode())
            return json.loads(p.stdout.decode())

        def prepare_file(path):
            if not os.path.exists(path):
                raise FileNotFoundError(path)

            if os.path.isfile(path):
                name = os.path.basename(path)
                safe = encode_special_chars(name)
                if safe != name:
                    tmp = os.path.join(tempfile.gettempdir(), safe)
                    shutil.copy2(path, tmp)
                    return tmp, tmp
                return path, None

            safe = encode_special_chars(os.path.basename(path))
            zip_path = os.path.join(
                tempfile.gettempdir(),
                f"{safe}_{uuid.uuid4().hex}.zip"
            )
            shutil.make_archive(zip_path[:-4], "zip", path)
            return zip_path, zip_path

        def upload_and_get_url(path):
            prepared, tmp = prepare_file(path)
            resp = run_upload(prepared)
            rel = resp.get("cdnUrl")
            if not rel:
                raise ValueError("cdnUrl missing in response")
            full = f"{args.get_cdn.rstrip('/')}{rel}"
            return encode_special_chars(full), tmp

        tmp_files = []

        try:
            model_url, t1 = upload_and_get_url(args.model_pickle)
            meta_url, t2 = upload_and_get_url(args.model_metadata_cdn)
            tmp_files.extend(filter(None, [t1, t2]))

            out = {
                "name": args.name,
                "model_cdn": model_url,
                "model_metadata_cdn": meta_url
            }

            atomic_write_json(args.schema_cdn_json, out)

            print("[INFO] Upload complete")
            print("[CDN] Model:", model_url)
            print("[CDN] Metadata:", meta_url)

        except Exception:
            traceback.print_exc()
            raise
        finally:
            for f in tmp_files:
                try:
                    os.remove(f)
                except Exception:
                    pass
    args:
      - --model_pickle
      - {inputPath: model_pickle}
      - --model_metadata_cdn
      - {inputPath: model_metadata_cdn}
      - --bearer_token
      - {inputPath: bearer_token}
      - --domain
      - {inputValue: domain}
      - --get_cdn
      - {inputValue: get_cdn}
      - --name
      - {inputValue: name}
      - --schema_cdn_json
      - {outputPath: schema_cdn_json}
