name: Update Schema Row v1
description: Updates a row in a schema based on a mapping between column names and a JSON object.

inputs:
  - { name: schema_id, type: String, description: "The ID of the schema to update." }
  - { name: update_data_json, type: String, description: "JSON string containing the data to update." }
  - { name: mapping_json, type: String, description: "JSON string mapping column names to keys in update_data_json." }
  - { name: model_id, type: String, description: "The ID of the model to filter by." }
  - { name: execution_id, type: String, description: "The ID of the model to filter by." }
  - { name: tenant_id, type: string, description: "The ID of the tenant (path to file containing tenant id or '-1')." }
  - { name: project_id, type: String, description: "The ID of the project." }
  - { name: architecture_type, type: String, description: "The architecture type." }
  - { name: multiple_rows_json, type: String, description: "JSON string containing a list of rows to create or '-1'." }
  - { name: bearer_auth_token, type: string, description: "Path to file that contains the bearer token (or '-1')." }
  - { name: domain, type: String, description: "The domain for the API endpoint." }
  - { name: float_keys_json, type: String, description: "JSON string of a list of keys to be converted to float or '-1'."}

implementation:
  container:
    image: python:3.9-slim
    command:
      - sh
      - -c
      - |
        pip install --no-cache-dir requests urllib3 && exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import json
        import argparse
        import requests
        from requests.adapters import HTTPAdapter
        from urllib3.util.retry import Retry
        import os
        import sys

        parser = argparse.ArgumentParser()
        parser.add_argument('--schema_id', type=str, required=True)
        parser.add_argument('--update_data_json', type=str, required=True)
        parser.add_argument('--mapping_json', type=str, required=True)
        parser.add_argument('--model_id', type=str, required=True)
        parser.add_argument('--execution_id', type=str, required=True)
        parser.add_argument('--tenant_id', type=str, required=True)
        parser.add_argument('--project_id', type=str, required=True)
        parser.add_argument('--architecture_type', type=str, required=True)
        parser.add_argument('--multiple_rows_json', type=str, required=True)
        parser.add_argument('--bearer_auth_token', type=str, required=True)
        parser.add_argument('--domain', type=str, required=True)
        parser.add_argument('--float_keys_json', type=str, required=False, default='-1')
        args = parser.parse_args()

        # Helper to read file only if path isn't '-1'
        def read_file_if_path(path):
            if path and path != '-1':
                if os.path.exists(path):
                    with open(path, 'r') as f:
                        return f.read().strip()
                else:
                    print(f"Warning: file path '{path}' does not exist", file=sys.stderr)
                    return ''
            return ''

        bearer_auth_token = read_file_if_path(args.bearer_auth_token)
        tenant_id_file_value = read_file_if_path(args.tenant_id)

        print(" Input Data ")
        print("update_data_json:", args.update_data_json)
        print("mapping_json:", args.mapping_json)

        try:
            update_data = json.loads(args.update_data_json) if args.update_data_json else {}
        except json.JSONDecodeError as e:
            print("Error: update_data_json is not valid JSON:", e, file=sys.stderr)
            sys.exit(1)

        try:
            mapping = json.loads(args.mapping_json) if args.mapping_json else {}
        except json.JSONDecodeError as e:
            print("Error: mapping_json is not valid JSON:", e, file=sys.stderr)
            sys.exit(1)

        # Parse float_keys_json safely; default to empty list
        float_keys = []
        if getattr(args, 'float_keys_json', None) and args.float_keys_json != '-1':
            try:
                parsed = json.loads(args.float_keys_json)
                if isinstance(parsed, list):
                    float_keys = parsed
                else:
                    print("Warning: float_keys_json parsed but is not a list; ignoring.", file=sys.stderr)
            except json.JSONDecodeError:
                print("Warning: float_keys_json is not valid JSON; ignoring.", file=sys.stderr)

        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {bearer_auth_token}' if bearer_auth_token else ''
        }

        retry_strategy = Retry(
            total=3,
            status_forcelist=[408, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "PUT", "POST", "DELETE", "OPTIONS", "TRACE"],
            backoff_factor=1
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        http = requests.Session()
        http.mount("https://", adapter)
        http.mount("http://", adapter)

        def coerce_if_needed(key, value):
            if key in float_keys:
                try:
                    return float(value)
                except (ValueError, TypeError):
                    return value
            return value

        # MULTIPLE ROWS PATH
        if args.multiple_rows_json != '-1':
            try:
                rows_to_create = json.loads(args.multiple_rows_json)
                if not isinstance(rows_to_create, list):
                    raise ValueError("multiple_rows_json must be a JSON list when provided.")
            except Exception as e:
                print("Error parsing multiple_rows_json:", e, file=sys.stderr)
                sys.exit(1)

            for row in rows_to_create:
                if args.tenant_id != '-1' and tenant_id_file_value:
                    row['tenant_id'] = tenant_id_file_value
                if args.project_id != '-1':
                    row['projectId'] = args.project_id
                if args.architecture_type != '-1':
                    row['architecture_type'] = args.architecture_type
                if 'execution_id' not in row and args.execution_id != '-1':
                    row['execution_id'] = args.execution_id

            create_url = f"{args.domain.rstrip('/')}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
            create_payload = {"data": rows_to_create}

            print(" Creating Multiple Rows ")
            print("Request URL: POST", create_url)
            print("Request Headers:", json.dumps(headers))
            print("Request Payload:", json.dumps(create_payload, indent=2))

            try:
                response = http.post(create_url, headers=headers, data=json.dumps(create_payload), timeout=60)
                response.raise_for_status()
                print("Successfully created multiple model instances.")
                try:
                    print("Response:", response.json())
                except Exception:
                    print("Response text:", response.text)
            except requests.exceptions.RequestException as e:
                print("Error creating multiple model instances:", e, file=sys.stderr)
                print("Failed Request Payload:", json.dumps(create_payload, indent=2), file=sys.stderr)
                if getattr(e, 'response', None):
                    print("Response Status Code:", e.response.status_code, file=sys.stderr)
                    print("Response Content:", e.response.text, file=sys.stderr)
                sys.exit(1)

        else:
            # SINGLE ROW: check existence by execution_id
            check_url = f"{args.domain.rstrip('/')}/pi-entity-instances-service/v3.0/schemas/{args.schema_id}/instances/list"
            check_payload = {
                "dbType": "TIDB",
                "ownedOnly": True,
                "filter": {
                    "execution_id": args.execution_id
                }
            }

            print(" Checking for Existing Row with execution_id:", args.execution_id)
            print("Request URL: POST", check_url)
            print("Request Headers:", json.dumps(headers))
            print("Request Payload:", json.dumps(check_payload, indent=2))

            try:
                response = http.post(check_url, headers=headers, data=json.dumps(check_payload), timeout=60)
                response.raise_for_status()
                response_data = response.json()
            except requests.exceptions.RequestException as e:
                print("Error while checking for existing instance:", e, file=sys.stderr)
                if getattr(e, 'response', None):
                    print("Response Status Code:", e.response.status_code, file=sys.stderr)
                    print("Response Content:", e.response.text, file=sys.stderr)
                sys.exit(1)
            except ValueError as e:
                print("Error decoding JSON response from check endpoint:", e, file=sys.stderr)
                sys.exit(1)

            if response_data.get("content"):
                # Update existing row
                print(" Instance Found: Updating Row ")
                patch_requests = []
                for column, keys in mapping.items():
                    value_to_patch = None
                    if isinstance(keys, list):
                        # preserve types per key
                        nested = {}
                        for key in keys:
                            if key in update_data:
                                nested[key] = coerce_if_needed(key, update_data.get(key))
                        if nested:
                            value_to_patch = nested
                    else:
                        if keys in update_data:
                            value = update_data.get(keys)
                            value_to_patch = coerce_if_needed(keys, value)

                    if value_to_patch is not None:
                        patch_requests.append({
                            "operation": "REPLACE",
                            "path": column,
                            "value": value_to_patch
                        })

                update_url = f"{args.domain.rstrip('/')}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
                update_payload = {
                    "dbType": "TIDB",
                    "conditionalFilter": {
                        "conditions": [
                            {
                                "field": "execution_id",
                                "operator": "EQUAL",
                                "value": args.execution_id
                            }
                        ]
                    },
                    "partialUpdateRequests": [
                        {
                            "patch": patch_requests
                        }
                    ]
                }

                print("Request URL: PATCH", update_url)
                print("Request Headers:", json.dumps(headers))
                print("Request Payload:", json.dumps(update_payload, indent=2))

                try:
                    response = http.patch(update_url, headers=headers, data=json.dumps(update_payload), timeout=60)
                    response.raise_for_status()
                    print("Successfully updated the model instance.")
                    try:
                        print("Response:", response.json())
                    except Exception:
                        print("Response text:", response.text)
                except requests.exceptions.RequestException as e:
                    print("Error updating model instance:", e, file=sys.stderr)
                    if getattr(e, 'response', None):
                        print("Response Status Code:", e.response.status_code, file=sys.stderr)
                        print("Response Content:", e.response.text, file=sys.stderr)
                    sys.exit(1)

            else:
                # Create new row
                print(" No Instance Found: Creating New Row ")
                creation_data = {}
                for column, keys in mapping.items():
                    value_to_add = None
                    if isinstance(keys, list):
                        nested = {}
                        for key in keys:
                            if key in update_data:
                                nested[key] = coerce_if_needed(key, update_data.get(key))
                        if nested:
                            value_to_add = nested
                    else:
                        if keys in update_data:
                            value = update_data.get(keys)
                            value_to_add = coerce_if_needed(keys, value)

                    if value_to_add is not None:
                        creation_data[column] = value_to_add

                creation_data['execution_id'] = args.execution_id
                if args.model_id != '-1':
                    creation_data['model_id'] = args.model_id
                if args.tenant_id != '-1' and tenant_id_file_value:
                    creation_data['tenant_id'] = tenant_id_file_value
                if args.project_id != '-1':
                    creation_data['projectId'] = args.project_id
                if args.architecture_type != '-1':
                    creation_data['architecture_type'] = args.architecture_type

                create_url = f"{args.domain.rstrip('/')}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
                create_payload = {"data": [creation_data]}

                print("Request URL: POST", create_url)
                print("Request Headers:", json.dumps(headers))
                print("Request Payload:", json.dumps(create_payload, indent=2))

                try:
                    response = http.post(create_url, headers=headers, data=json.dumps(create_payload), timeout=60)
                    if response.status_code >= 400:
                        print(f"Error: {response.status_code} {response.reason}", file=sys.stderr)
                        print("Response Content:", response.text, file=sys.stderr)
                    response.raise_for_status()
                    print("Successfully created a new model instance.")
                    try:
                        print("Response:", response.json())
                    except Exception:
                        print("Response text:", response.text)
                except requests.exceptions.RequestException as e:
                    print("Error creating new model instance:", e, file=sys.stderr)
                    if getattr(e, 'response', None):
                        print("Response Status Code:", e.response.status_code, file=sys.stderr)
                        print("Response Content:", e.response.text, file=sys.stderr)
                    sys.exit(1)
    args:
      - --schema_id
      - {inputValue: schema_id}
      - --update_data_json
      - {inputValue: update_data_json}
      - --mapping_json
      - {inputValue: mapping_json}
      - --model_id
      - {inputValue: model_id}
      - --execution_id
      - {inputValue: execution_id}
      - --tenant_id
      - {inputPath: tenant_id}
      - --project_id
      - {inputValue: project_id}
      - --architecture_type
      - {inputValue: architecture_type}
      - --multiple_rows_json
      - {inputValue: multiple_rows_json}
      - --bearer_auth_token
      - {inputPath: bearer_auth_token}
      - --domain
      - {inputValue: domain}
      - --float_keys_json
      - {inputValue: float_keys_json}
