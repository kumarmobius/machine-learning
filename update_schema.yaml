name: Update Schema Row v2
description: Updates a row in a schema based on a mapping between column names and a JSON object.

inputs:
  - { name: schema_id, type: String }
  - { name: update_data_json, type: String }
  - { name: mapping_json, type: String }
  - { name: model_id, type: Integer }
  - { name: execution_id, type: Integer }
  - { name: tenant_id, type: string }
  - { name: project_id, type: String }
  - { name: architecture_type, type: String }
  - { name: multiple_rows_json, type: String }
  - { name: bearer_auth_token, type: string }
  - { name: domain, type: String }
  - { name: float_keys_json, type: String }

implementation:
  container:
    image: python:3.9-slim
    command:
      - sh
      - -c
      - |
        pip install --no-cache-dir requests urllib3 && exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import json
        import argparse
        import requests
        from requests.adapters import HTTPAdapter
        from urllib3.util.retry import Retry
        import os
        import sys

        parser = argparse.ArgumentParser()
        parser.add_argument('--schema_id', type=str, required=True)
        parser.add_argument('--update_data_json', type=str, required=True)
        parser.add_argument('--mapping_json', type=str, required=True)
        parser.add_argument('--model_id', type=str, required=True)
        parser.add_argument('--execution_id', type=str, required=True)
        parser.add_argument('--tenant_id', type=str, required=True)
        parser.add_argument('--project_id', type=str, required=True)
        parser.add_argument('--architecture_type', type=str, required=True)
        parser.add_argument('--multiple_rows_json', type=str, required=True)
        parser.add_argument('--bearer_auth_token', type=str, required=True)
        parser.add_argument('--domain', type=str, required=True)
        parser.add_argument('--float_keys_json', type=str, required=False, default='-1')
        args = parser.parse_args()

        # ----------------------------
        # NUMERIC FIX FOR execution_id
        # ----------------------------
        def _smart_numeric_parse(v):
            if v is None:
                return v
            if isinstance(v, str) and v.strip() == "-1":
                return v
            try:
                parsed = json.loads(v)
                if isinstance(parsed, (int, float)):
                    return parsed
            except:
                pass
            try:
                if "." in v:
                    return float(v)
                return int(v)
            except:
                return v

        execution_id = _smart_numeric_parse(args.execution_id)
        model_id = _smart_numeric_parse(args.model_id)
        project_id_val = _smart_numeric_parse(args.project_id)

        # READ FILES
        def read_file_if_path(path):
            if path and path != '-1':
                if os.path.exists(path):
                    with open(path, 'r') as f:
                        return f.read().strip()
                else:
                    print(f"Warning: file '{path}' not found", file=sys.stderr)
                    return ''
            return ''

        bearer_auth_token = read_file_if_path(args.bearer_auth_token)
        tenant_id_file_value = read_file_if_path(args.tenant_id)

        try:
            update_data = json.loads(args.update_data_json)
            mapping = json.loads(args.mapping_json)
        except Exception as e:
            print("Invalid JSON:", e, file=sys.stderr)
            sys.exit(1)

        float_keys = []
        if args.float_keys_json != "-1":
            try:
                fk = json.loads(args.float_keys_json)
                if isinstance(fk, list):
                    float_keys = fk
            except:
                print("Warning: invalid float_keys_json", file=sys.stderr)

        def coerce_if_needed(key, value):
            if key in float_keys:
                try:
                    return float(value)
                except:
                    return value
            return value

        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {bearer_auth_token}" if bearer_auth_token else ""
        }

        retry_strategy = Retry(
            total=3,
            status_forcelist=[408, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "PUT", "POST", "PATCH", "DELETE", "OPTIONS"],
            backoff_factor=1
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        http = requests.Session()
        http.mount("http://", adapter)
        http.mount("https://", adapter)

        # MULTIPLE ROWS PATH
        if args.multiple_rows_json != "-1":
            try:
                rows = json.loads(args.multiple_rows_json)
                if not isinstance(rows, list):
                    raise Exception("multiple_rows_json must be list")
            except Exception as e:
                print("Error in multiple_rows_json:", e, file=sys.stderr)
                sys.exit(1)

            for row in rows:
                if args.tenant_id != "-1" and tenant_id_file_value:
                    row["tenant_id"] = tenant_id_file_value
                if args.project_id != "-1":
                    row["projectId"] = project_id_val
                if args.architecture_type != "-1":
                    row["architecture_type"] = args.architecture_type
                if "execution_id" not in row:
                    row["execution_id"] = execution_id

            create_url = f"{args.domain.rstrip('/')}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
            payload = {"data": rows}
            resp = http.post(create_url, headers=headers, data=json.dumps(payload))
            print(resp.text)
            resp.raise_for_status()
            sys.exit(0)

        # SINGLE ROW – CHECK EXISTENCE
        check_url = f"{args.domain.rstrip('/')}/pi-entity-instances-service/v3.0/schemas/{args.schema_id}/instances/list"
        check_payload = {
            "dbType": "TIDB",
            "ownedOnly": True,
            "filter": {"execution_id": execution_id}
        }

        resp = http.post(check_url, headers=headers, data=json.dumps(check_payload))
        resp.raise_for_status()
        data = resp.json()

        # If row exists → UPDATE
        if data.get("content"):
            patch_list = []
            for column, keys in mapping.items():
                if isinstance(keys, list):
                    obj = {}
                    for k in keys:
                        if k in update_data:
                            obj[k] = coerce_if_needed(k, update_data[k])
                    if obj:
                        patch_list.append({"operation": "REPLACE", "path": column, "value": obj})
                else:
                    if keys in update_data:
                        patch_list.append({
                            "operation": "REPLACE",
                            "path": column,
                            "value": coerce_if_needed(keys, update_data[keys])
                        })

            update_url = f"{args.domain.rstrip('/')}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
            update_payload = {
                "dbType": "TIDB",
                "conditionalFilter": {
                    "conditions": [
                        {"field": "execution_id", "operator": "EQUAL", "value": execution_id}
                    ]
                },
                "partialUpdateRequests": [{"patch": patch_list}]
            }

            resp = http.patch(update_url, headers=headers, data=json.dumps(update_payload))
            print(resp.text)
            resp.raise_for_status()

        else:
            # CREATE NEW ROW
            creation = {}
            for column, keys in mapping.items():
                if isinstance(keys, list):
                    obj = {}
                    for k in keys:
                        if k in update_data:
                            obj[k] = coerce_if_needed(k, update_data[k])
                    if obj:
                        creation[column] = obj
                else:
                    if keys in update_data:
                        creation[column] = coerce_if_needed(keys, update_data[keys])

            creation["execution_id"] = execution_id
            creation["model_id"] = model_id
            if tenant_id_file_value:
                creation["tenant_id"] = tenant_id_file_value
            creation["projectId"] = project_id_val
            creation["architecture_type"] = args.architecture_type

            create_url = f"{args.domain.rstrip('/')}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
            payload = {"data": [creation]}

            resp = http.post(create_url, headers=headers, data=json.dumps(payload))
            print(resp.text)
            resp.raise_for_status()

    args:
      - --schema_id
      - {inputValue: schema_id}
      - --update_data_json
      - {inputValue: update_data_json}
      - --mapping_json
      - {inputValue: mapping_json}
      - --model_id
      - {inputValue: model_id}
      - --execution_id
      - {inputValue: execution_id}
      - --tenant_id
      - {inputPath: tenant_id}
      - --project_id
      - {inputValue: project_id}
      - --architecture_type
      - {inputValue: architecture_type}
      - --multiple_rows_json
      - {inputValue: multiple_rows_json}
      - --bearer_auth_token
      - {inputPath: bearer_auth_token}
      - --domain
      - {inputValue: domain}
      - --float_keys_json
      - {inputValue: float_keys_json}
